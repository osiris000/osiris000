#!/bin/bash
# pilottv

# Variables de configuración
SCRIPT_NAME="pilottv"
OUTPUT_URL=${1:-"rtmp://a.rtmp.youtube.com/live2/g8pm-sau2-va7c-tyg5-1ppy"}
INSPECTOR_TIME=${2:-3}
FFMPEG_CMD="ffmpeg -re -stream_loop -1 -i com/datas/ffmpeg/intro.mp4 \
    -c:v libx264 -preset veryfast -crf 23 -b:v 3000k -maxrate 3500k \
    -bufsize 7000k -pix_fmt yuv420p -g 50 -metadata text=osiris-pilot-tv \
    -f flv $OUTPUT_URL"

# Obtener la ruta completa del script
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")

# Cambiar al directorio del script
cd "$SCRIPT_DIR" || { echo "Failed to change directory to $SCRIPT_DIR"; exit 1; }

# Función para obtener los PIDs de los procesos FFmpeg que contienen "osiristvscreen"
get_osiristvscreen_pids() {
    ps aux | grep '[f]fmpeg' | grep "osiristvscreen" | awk '{print $2}'
}

# Función para obtener los PIDs de los procesos FFmpeg que contienen "osiris-pilot-tv"
get_pilot_pids() {
    ps aux | grep '[f]fmpeg' | grep "osiris-pilot-tv" | awk '{print $2}'
}

# Función para iniciar FFmpeg con los parámetros iniciales
start_ffmpeg() {
    echo "Iniciando FFmpeg (osiris-pilot-tv) con parámetros por defecto..."
    echo "$FFMPEG_CMD"
    # Ejecutar el comando FFmpeg en segundo plano
    $FFMPEG_CMD >/dev/null 2>&1 &
}

# Función para verificar si un PID aún está activo
is_pid_active() {
    ps -p "$1" > /dev/null 2>&1
}

# Función para matar un proceso de forma ordenada y luego forzarlo si es necesario
kill_process() {
    local pid=$1
    echo "Intentando matar el proceso con PID: $pid de forma ordenada..."
    kill "$pid"
    sleep 2

    if is_pid_active "$pid"; then
        echo "El proceso $pid sigue activo, intentándolo de nuevo..."
        kill -15 "$pid"
        sleep 2

        if is_pid_active "$pid"; then
            echo "No se pudo matar el proceso $pid, forzando terminación con sudo..."
            sudo kill -9 "$pid"
        fi
    fi
}

# Bucle principal de inspección
while true; do
    clear
    echo "Comprobando procesos FFmpeg..."

    # Obtener los PIDs de los procesos FFmpeg con "osiristvscreen" en su comando
    ffmpeg_pids=$(get_osiristvscreen_pids)
    pid_count=$(echo "$ffmpeg_pids" | wc -w)

    # Obtener los PIDs de los procesos FFmpeg con "osiris-pilot-tv"
    pilot_pids=$(get_pilot_pids)

    if [ "$pid_count" -eq 0 ]; then
        # No hay procesos osiristvscreen
        echo "No se encontraron procesos FFmpeg con 'osiristvscreen'."

        if [ -z "$pilot_pids" ]; then
            # No hay procesos osiris-pilot-tv, iniciar uno nuevo
            echo "No se encontró un proceso osiris-pilot-tv en ejecución. Iniciando..."
            start_ffmpeg
        else
            echo "Proceso osiris-pilot-tv ya en ejecución."
        fi
    else
        # Hay procesos osiristvscreen
        echo "Procesos FFmpeg con 'osiristvscreen' detectados: $ffmpeg_pids"

        # Matar los procesos osiris-pilot-tv si existen
        if [ ! -z "$pilot_pids" ]; then
            echo "PIDs de procesos osiris-pilot-tv encontrados: $pilot_pids"
            for pid in $pilot_pids; do
                if is_pid_active "$pid"; then
                    echo "Matando proceso osiris-pilot-tv con PID: $pid..."
                    kill_process "$pid"
                fi
            done
        fi

        # Verificar y manejar múltiples procesos osiristvscreen
        if [ "$pid_count" -gt 1 ]; then
            echo "Se encontraron múltiples procesos FFmpeg con 'osiristvscreen'. PIDs detectados: $ffmpeg_pids"
            latest_pid=$(echo "$ffmpeg_pids" | sort -n | tail -n 1)

            for pid in $ffmpeg_pids; do
                if [ "$pid" -ne "$latest_pid" ]; then
                    echo "Matando proceso FFmpeg con PID: $pid"
                    kill_process "$pid"
                fi
            done
        else
            echo "Un solo proceso FFmpeg en ejecución con PID: $ffmpeg_pids"
        fi
    fi

    sleep $INSPECTOR_TIME  # Esperar antes de la próxima verificación
done
